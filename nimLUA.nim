# nimLUA
# glue code generator to bind Nim and Lua together using Nim's powerful macro
#
# Copyright (c) 2015 Andri Lim
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
#-------------------------------------

import macros, nimLUA/lua, strutils
export lua, macros

type
  BindKind* = enum
    isNothing
    isClosure
    isDestructor

  bindDesc* = ref object
    node*: NimNode #this is nnkSym or nnkClosedSymChoice node generated by bindSym,
                  # bindXXXImpl will then use getImpl to get the AST body of proc/const/enum/etc implementation
    name*: string  #newname that will be exported, taken from  abc -> "newname", or oldname if no newname supplied
    lhsKind*: NimNodeKind #op '->' lhs kind, it could be nnkIdent or nnkAccQuoted
    rhsKind*: NimNodeKind  #op '->' rhs kind, it could be nnkNone or nnkStrLit or nnkIdent
    bindKind*: BindKind
    genericParams*: seq[NimNode]

  propDesc = tuple [
    node: string,
    name: string,
    lhsKind: NimNodeKind,
    getter: bool,
    setter: bool
  ]

  proxyDesc* = object
    luaCtx*  : string
    libName* : NimNode
    subject* : NimNode
    bindList*: seq[bindDesc]
    symList* : seq[NimNode]
    propList*: seq[propDesc]

  argDesc = object
    mName, mType, mVal: NimNode

  bindFlag = enum
    nlbUseLib
    nlbRegisterObject
    nlbRegisterClosure
    nlbRegisterGeneric

  bindFlags = set[bindFlag]

  ovProcElem = ref object
    retType: NimNode
    params: seq[argDesc]

  ovProc = ref object
    numArgs: int
    procs: seq[ovProcElem]

  ovList = seq[ovProc]

  ovFlag = enum
    ovfUseObject
    ovfUseRet
    ovfConstructor

  ovFlags = set[ovFlag]

  nlOptions* = enum
    nloNone
    nloDebug
    nloAddMember

  NLError* = object
    source: string
    currentLine: int
    msg: string

  NLErrorFunc* = proc(ctx: pointer, err: NLError) {.nimcall.}

let globalClosure {.compileTime.} = "_gCLV"

const
  IDRegion = 0xEF
  IDErrorContext = IDRegion - 1
  IDErrorFunc = IDRegion - 2
  NLMaxID* = 0xFFF

template luaError*(x: PState, m: string): untyped =
  lua.error(x, m)

template newuserdata*(L: PState, sz: int): pointer =
  newuserdata(L, sz.csize_t)

template pushlstring*(L: PState, s: cstring, len: int): cstring =
  pushlstring(L, s, len.csize_t)

proc isStrictString*(L: PState, idx: int): bool {.inline.} =
  luaType(L, idx.cint) == LUA_TSTRING.cint

#counter that will be used to generate unique intermediate macro name
#and avoid name collision
var
  macroCount {.compileTime.} = 0
  proxyCount {.compileTime.} = 0
  regsCount  {.compileTime.} = 0
  nameList   {.compileTime.} = newSeq[string]()
  outValList {.compileTime.} : seq[string]
  gContext   {.compileTime.} = ""
  gOptions   {.compileTime.} = {nloAddMember}
  objectMTList {.compileTime.} = newSeq[string]()

proc convOpt(a: NimNode): nlOptions {.compileTime.} =
  case $a:
  of "nloDebug": result = nloDebug
  of "nloAddMember": result = nloAddMember
  else: result = nloNone

macro nimLuaOptions*(opt: nlOptions, mode: bool): untyped =
  if $mode == "true":
    gOptions.incl convOpt(opt)
  else:
    gOptions.excl convOpt(opt)

  result = newEmptyNode()

proc toString(c: LUA_TYPE): string =
  const typeName = ["NIL", "BOOLEAN", "LIGHTUSERDATA", "NUMBER", "STRING",
    "TABLE", "FUNCTION", "USERDATA", "THREAD", "NUMTAGS"]
  if c in {LNIL..LNUMTAGS}:
    return typeName[ord(c)]
  elif c == LNONE:
    return "NONE"
  else:
    return "INVALID"

proc nimDebug(L: PState, idx: cint, eType: string) =
  var dbg: TDebug
  if L.getStack(1, dbg.addr) != 0:
    if L.getInfo("Sln", dbg.addr) != 0:
      let gType = L.getType(idx).toString()
      let err = NLError(source: $dbg.source, currentLine: dbg.currentLine,
        msg: "expected `$1`, got `$2`" % [eType, $gType])
      L.pushLightUserData(cast[pointer](IDErrorContext))
      L.rawGet(LUA_REGISTRYINDEX) # get correct error context
      let errCtx = L.toUserData(-1)
      L.pushLightUserData(cast[pointer](IDErrorFunc))
      L.rawGet(LUA_REGISTRYINDEX) # get correct error function
      let errFunc = cast[NLErrorFunc](L.toUserData(-1))
      L.pop(2)
      errFunc(errCtx, err)

#inside macro, const bool become nnkIntLit, that's why we need to use
#this trick to test for bool type using 'when internalTestForBOOL(n)'
proc internalTestForBOOL*[T](a: T): bool {.compileTime.} =
  when a is bool: result = true
  else: result = false

proc parseCode(s: string): NimNode {.compileTime.} =
  result = parseStmt(s)
  if nloDebug in gOptions: echo s

#flatten formal param into seq
proc paramsToArgListBasic(params: NimNode, start = 1): seq[argDesc] {.compileTime.} =
  var argList = newSeq[argDesc]()
  for i in start..params.len-1:
    let arg = params[i]
    let mType = arg[arg.len - 2]
    let mVal = arg[arg.len - 1]
    for j in 0..arg.len-3:
      argList.add(argDesc(mName: arg[j], mType: mType, mVal: mVal))
  result = argList

proc paramsToArgList(params: NimNode, subs: seq[NimNode], templateParam: NimNode): seq[argDesc] {.compileTime.} =
  var p = paramsToArgListBasic(params)
  for i in 0..templateParam.len-1:
    for j in 0..p.len-1:
      if p[j].mType.kind == nnkVarTy:
        if p[j].mType[0].kind == nnkBracketExpr:
          if $p[j].mType[0][1] == $templateParam[i]:
            if i < subs.len: p[j].mType[0][1] = subs[i]
        else:
          if $p[j].mType[0] == $templateParam[i]:
            if i < subs.len: p[j].mType[0] = subs[i]
      else:
        if $p[j].mType == $templateParam[i]:
          if i < subs.len: p[j].mType = subs[i]

  result = p

proc replaceRet(ret: NimNode, subs: seq[NimNode], templateParam: NimNode): NimNode {.compileTime.} =
  for i in 0..templateParam.len-1:
    if ret.kind != nnkEmpty:
      if $ret == $templateParam[i]:
        if i < subs.len: return subs[i]
  result = ret

proc newBindDesc*(node: NimNode, name: string, lhsKind, rhsKind: NimNodeKind,
  kind = isNothing, genericParams: seq[NimNode] = @[]): bindDesc {.compileTime.} =
  new(result)
  result.node = node
  result.name = name
  result.lhsKind = lhsKind
  result.rhsKind = rhsKind
  result.bindKind = kind
  result.genericParams = genericParams

proc collectGenericParam(p: bindDesc, n: NimNode) {.compileTime.} =
  for i in 1..n.len-1:
    p.genericParams.add n[i]

#split something like 'ident -> "newName"' into tuple
proc splitElem(n: NimNode, opts: bindFlags, proxyName: string): bindDesc {.compileTime.} =
  let
    op  = n[0]
    lhs = n[1]
    rhs = n[2]
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  if $op != "->":
    error("wrong operator, must be '->' and not '" & $op & "'")
  if lhs.kind notin {nnkIdent, nnkAccQuoted, nnkCall, nnkBracket, nnkBracketExpr}:
    error("param must be an identifier and not " & $lhs.kind)
  if not registerObject and lhs.kind == nnkCall:
    error("getter/setter not available in bind$1" % [proxyName])
  if not registerClosure and lhs.kind == nnkBracket:
    error("closure not available in bind$1" % [proxyName])
  if not registerGeneric and lhs.kind == nnkBracketExpr:
    error("generic not available in bind$1" % [proxyName])
  if rhs.kind notin {nnkStrLit, nnkIdent}:
    error("alias must be string literal and not " & $rhs.kind)

  if lhs.kind == nnkAccQuoted:
    result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind)
  elif lhs.kind == nnkBracket:
    if lhs[0].kind == nnkAccQuoted:
      result = newBindDesc(lhs[0][0], $rhs, lhs[0].kind, rhs.kind, isClosure)
    else:
      result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind, isClosure)
  elif lhs.kind == nnkBracketExpr:
    if lhs[0].kind == nnkAccQuoted:
      result = newBindDesc(lhs[0][0], $rhs, lhs[0].kind, rhs.kind)
    else:
      result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind)
    collectGenericParam(result, lhs)
  else:
    result = newBindDesc(lhs, $rhs, lhs.kind, rhs.kind)

#helper proc to flatten nnkStmtList
proc unwindList(arg: NimNode, elemList: var seq[bindDesc], opts: bindFlags, proxyName: string) {.compileTime.} =
  let
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  for i in 0..arg.len-1:
    let n = arg[i]
    case n.kind:
    of nnkIdent:
      let elem = newBindDesc(n, $n, n.kind, nnkNone)
      elemList.add elem
    of nnkAccQuoted:
      let elem = newBindDesc(n[0], "`" & $n[0] & "`", n.kind, nnkNone)
      elemList.add elem
    of nnkInfix:
      elemList.add splitElem(n, opts, proxyName)
    of nnkCall:
      if not registerObject:
        error("getter/setter not available in bind$1" % [proxyName])
      let elem = newBindDesc(n, $n[0], n.kind, nnkNone)
      elemList.add elem
    of nnkBracket:
      if not registerClosure:
        error("closure not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, isClosure)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, isClosure)
      elemList.add elem
    of nnkBracketExpr:
      if not registerGeneric:
        error("generic not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone)
      collectGenericParam(elem, n)
      elemList.add elem
    of nnkPrefix:
      if $n[0] != "~": error("only `~` prefix supported", n[0])
      let elem = newBindDesc(n[1], "__gc", n.kind, nnkNone, isDestructor)
      elemList.add elem
    else:
      error("wrong param type: $1, $2 not allowed here" % [$n.kind, n.toStrLit().strVal], n)

proc checkDuplicate(list: seq[bindDesc]): string {.compileTime.} =
  var checked = newSeq[bindDesc]()
  for k in list:
    if checked.contains(k):
      return $k.node
    else:
      checked.add k
  result = ""

#here is the factory of second level macro that will be expanded to utilize bindSym
proc genProxyMacro(arg: NimNode, opts: bindFlags, proxyName: string): NimNode {.compileTime.} =
  let
    useLib = nlbUseLib in opts
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  var
    luaCtx   = ""
    libName  = ""
    libKind: NimNodeKind
    objectName = ""
    objectNewName = ""
    elemList = newSeq[bindDesc]()
    propList = newSeq[propDesc]()

  for i in 0..arg.len-1:
    let n = arg[i]
    case n.kind
    of nnkSym:
      if i == 0: luaCtx = $n
      else:
        error("param " & $i & " must be an identifier, not symbol\n" & arg.treeRepr)
    of nnkStrLit:
      if i == 1 and useLib:
        libName = n.strVal
        libKind = n.kind
      else:
        let msg = "bind$1, param: $2" % [proxyName, n.toStrLit().strVal]
        error("param " & $i & " must be an identifier, not string literal\n" & msg, n)
    of nnkIdent:
      if i == 1 and $n == "GLOBAL" and useLib:
        libName = $n
        libKind = n.kind
      elif i == 1 and registerObject:
        objectName = $n
        objectNewName = $n
      else:
        let elem = newBindDesc(n, $n, n.kind, nnkNone)
        elemList.add elem
    of nnkAccQuoted:
      let elem = newBindDesc(n[0], "`" & $n[0] & "`", n.kind, nnkNone)
      elemList.add elem
    of nnkInfix:
      if registerObject and i == 1:
        let k = splitElem(n, opts, proxyName)
        objectName = $k.node
        objectNewName = k.name
      else:
        elemList.add splitElem(n, opts, proxyName)
    of nnkCall:
      if not registerObject:
        error("getter/setter not available in bind$1" % [proxyName])
      let elem = newBindDesc(n, $n[0], n.kind, nnkNone)
      elemList.add elem
    of nnkBracket:
      if not registerClosure:
        error("closure not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, isClosure)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, isClosure)
      elemList.add elem
    of nnkBracketExpr:
      if not registerGeneric:
        error("generic not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone)
      collectGenericParam(elem, n)
      elemList.add elem
    of nnkStmtList:
      unwindList(n, elemList, opts, proxyName)
    of nnkPrefix:
      if $n[0] != "~": error("only `~` prefix supported", n[0])
      let elem = newBindDesc(n[1], "__gc", n.kind, nnkNone, isDestructor)
      elemList.add elem
    else:
      error("wrong param type\n" & n.treeRepr, n)

  if luaCtx == "":
    error("need luaState as first param")

  let dup = elemList.checkDuplicate()
  if dup != "":
    error("bind$1 detected duplicated entries: $2" % [proxyName, dup])

  #generate intermediate macro to utilize bindSym that can only accept string literal
  let macroName = "NLB$1$2" % [proxyName, $macroCount]
  var nlb = "macro " & macroName & "(): untyped =\n"
  nlb.add "  var ctx: proxyDesc\n"
  nlb.add "  ctx.luaCtx = \"$1\"\n" % [luaCtx]
  if registerObject:
    nlb.add "  ctx.subject = bindSym\"$1\"\n" % [objectName]
  else:
    nlb.add "  ctx.subject = newEmptyNode()\n"

  var numElem = 0
  for k in elemList:
    if k.node.kind in {nnkAccQuoted, nnkIdent}:
      inc numElem
    elif k.node.kind == nnkCall:
      var v = if k.node[0].kind == nnkAccQuoted:
          (node: $k.node[0][0], name: "`" & $k.node[0][0] & "`", lhsKind: k.node[0].kind, getter: false, setter: false)
        else:
          (node: $k.node[0], name: $k.node[0], lhsKind: k.node[0].kind, getter: false, setter: false)

      if k.rhsKind in {nnkStrLit, nnkIdent}: v.name = k.name

      for i in 1..k.node.len-1:
        let n = k.node[i]
        if n.kind != nnkIdent: error(v.node & ": getter/setter attribut must be identifier")
        if $n == "get": v.getter = true
        elif $n == "set": v.setter = true
        else: error(v.node & ": getter/setter attribute must be 'get' and/or 'set'")
      if v.getter == false and v.setter == false: error(v.node & ": getter/setter attribute must be present")
      propList.add v
    else:
      error("unexpected node kind: " & $k.node.kind)

  if numElem > 0:
    nlb.add "  ctx.bindList = @[\n"
    var i = 0
    for k in elemList:
      let comma = if i < numElem: "," else: ""
      if k.node.kind in {nnkAccQuoted, nnkIdent}:
        var gp = ""
        if k.genericParams.len > 0:
          gp.add "@["
          var ii = 0
          for x in k.genericParams:
            let cma = if ii < k.genericParams.len-1: "," else: ""
            gp.add "bindSym\"$1\"$2" % [$x, cma]
            inc ii
          gp.add "]"
        else:
          gp.add "newSeq[NimNode]()"
        nlb.add "    newBindDesc(bindSym\"$1\", \"$2\", $3, $4, $5, $6)$7\n" %
          [$k.node, k.name, $k.lhsKind, $k.rhsKind, $k.bindKind, gp, comma]
        inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.bindList = @[]\n"

  if propList.len > 0:
    nlb.add "  ctx.propList = @[\n"
    var ii = 0
    for k in propList:
      let comma = if ii < propList.len-1: "," else: ""
      nlb.add "    (\"$1\", \"$2\", $3, $4, $5)$6\n" %
        [k.node, k.name, $k.lhsKind, $k.getter, $k.setter, comma]
      inc ii
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.propList = @[]\n"

  if libKind == nnkStrLit:
    nlb.add "  ctx.libName = newStrLitNode(\"$1\")\n" % [libName]
  elif libKind == nnkIdent:
    nlb.add "  ctx.libName = newIdentNode(\"$1\")\n" % [libName]
  elif registerObject:
    nlb.add "  ctx.libName = newIdentNode(\"$1\")\n" % [objectNewName]
  else:
    nlb.add "  ctx.libName = newEmptyNode()\n"

  nlb.add "  result = proxyMixer(ctx, \"$1\")\n" % [proxyName]
  nlb.add macroName & "()\n"

  result = parseCode(nlb)
  inc macroCount

#both normal ident and backticks quoted ident converted to string
proc getAccQuotedName(n: NimNode, kind: NimNodeKind): string {.compileTime.} =
  let name = if n.kind == nnkClosedSymChoice: $n[0] else: $n
  if kind == nnkAccQuoted: result = "`" & name & "`" else: result = name

proc getAccQuotedName(name: string, kind: NimNodeKind): string {.compileTime.} =
  if kind == nnkAccQuoted: result = "`" & name & "`" else: result = name

proc ignoreGenerics(ids: var seq[string], id: string, generics: NimNode) {.compileTime.} =
  var found = false
  if generics.kind == nnkGenericParams:
    for k in generics:
      if $k == id:
        found = true
        break
  if not found: ids.add id

proc collectSym(ids: var seq[string], arg: NimNode) {.compileTime.} =
  if arg.kind == nnkProcDef:
    let generics = arg[2]
    let params  = arg[3]
    let retType = params[0]
    let argList = paramsToArgListBasic(params)
    if retType.kind == nnkIdent: ignoreGenerics(ids, $retType, generics)
    for k in argList:
      if k.mType.kind == nnkIdent: ignoreGenerics(ids, $k.mType, generics)
      if k.mVal.kind == nnkIdent: ignoreGenerics(ids, $k.mVal, generics)

proc checkProp(subject: NimNode, prop: string): bool {.compileTime.} =
  let parent = if subject.kind == nnkRefTy: subject[0][1] else: subject[1]
  if parent.kind == nnkOfInherit:
    let parentName = parent[0]
    var t = getTypeImpl(parentName)
    if t.kind == nnkRefTy: t = getTypeImpl(t[0])
    if checkProp(t, prop): return true

  let recList = if subject.kind == nnkRefTy: subject[0][2] else: subject[2]
  if recList.kind == nnkEmpty: return false

  for n in recList:
    for i in 0..n.len-3:
      let k = n[i]
      if k.kind in {nnkIdent, nnkSym}:
        if $k == prop: return true
      elif k.kind == nnkPostfix:
        if $k[1] == prop: return true
      else:
        error("unknown prop construct")
  result = false

proc checkObject(subject: NimNode): bool {.compileTime.} =
  if subject[2].kind == nnkDistinctTy:
    return subject[2][0].kind == nnkSym and $subject[2][0] == "pointer"
  result = subject[2].kind in {nnkObjectTy, nnkRefTy}

proc proxyMixer*(ctx: proxyDesc, proxyName: string): NimNode {.compileTime.} =
  var ids = newSeq[string]()

  for n in ctx.bindList:
    if n.node.kind == nnkSym:
      let im = getImpl(n.node)
      collectSym(ids, im)
    else:
      for s in children(n.node):
        let im = getImpl(s)
        collectSym(ids, im)

  let macroName = "NLB$1$2" % [proxyName, $macroCount]
  var nlb = "macro " & macroName & "(): untyped =\n"
  nlb.add "  var ctx: proxyDesc\n"
  nlb.add "  ctx.luaCtx = \"$1\"\n" % [ctx.luaCtx]
  if ctx.subject.kind == nnkSym:
    let subject = getImpl(ctx.subject)
    if not checkObject(subject):
      error($ctx.subject & ": not an object")
    nlb.add "  ctx.subject = bindSym\"$1\"\n" % [$ctx.subject]
  else:
    nlb.add "  ctx.subject = newEmptyNode()\n"

  if ctx.bindList.len > 0:
    nlb.add "  ctx.bindList = @[\n"
    var i = 0
    for k in ctx.bindList:
      var gp = ""
      if k.genericParams.len > 0:
        gp.add "@["
        var ii = 0
        for x in k.genericParams:
          let cma = if ii < k.genericParams.len-1: "," else: ""
          gp.add "bindSym\"$1\"$2" % [$x, cma]
          inc ii
        gp.add "]"
      else:
        gp.add "newSeq[NimNode]()"

      let comma = if i < ctx.bindList.len-1: "," else: ""
      nlb.add "    newBindDesc(bindSym\"$1\", \"$2\", $3, $4, $5, $6)$7\n" %
        [$k.node, k.name, $k.lhsKind, $k.rhsKind, $k.bindKind, gp, comma]
      inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.bindList = @[]\n"

  if ctx.propList.len > 0:
    nlb.add "  ctx.propList = @[\n"
    var ii = 0
    let subject = getImpl(ctx.subject)
    for k in ctx.propList:
      if not checkProp(subject[2], k.node):
        error($ctx.subject & ": don't have properties " & k.name)
      let comma = if ii < ctx.propList.len-1: "," else: ""
      nlb.add "    (\"$1\", \"$2\", $3, $4, $5)$6\n" %
        [k.node, k.name, $k.lhsKind, $k.getter, $k.setter, comma]
      inc ii
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.propList = @[]\n"

  if ids.len > 0:
    nlb.add "  ctx.symList = @[\n"
    var i = 0
    for k in ids:
      let comma = if i < ids.len-1: "," else: ""
      nlb.add "    bindSym\"$1\"$2\n" % [k, comma]
      inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.symList = @[]\n"

  if ctx.libName.kind == nnkStrLit:
    nlb.add "  ctx.libName = newStrLitNode(\"$1\")\n" % [$ctx.libName]
  elif ctx.libName.kind == nnkIdent:
    nlb.add "  ctx.libName = newIdentNode(\"$1\")\n" % [$ctx.libName]
  else:
    nlb.add "  ctx.libName = newEmptyNode()\n"

  nlb.add "  result = bind$1Impl(ctx)\n" % [proxyName]
  nlb.add macroName & "()\n"

  result = parseCode(nlb)
  inc macroCount

#proc params and return type
proc newProcElem(retType: NimNode, params: seq[argDesc]): ovProcElem {.compileTime.} =
  result = new(ovProcElem)
  result.retType = retType
  result.params = params

#list of overloaded proc
proc newOvProc(retType: NimNode, params: seq[argDesc]): ovProc {.compileTime.} =
  var ovp = new(ovProc)
  ovp.numArgs = params.len
  ovp.procs = newSeq[ovProcElem]()
  ovp.procs.add newProcElem(retType, params)
  result = ovp

#add overloaded proc into ovList
proc addOvProc(ovl: var ovList, retType: NimNode, params: seq[argDesc]) {.compileTime.} =
  var found = false
  for k in ovl:
    if k.numArgs == params.len:
      k.procs.add newProcElem(retType, params)
      found = true
      break

  if not found:
    ovl.add newOvProc(retType, params)

proc isRefType(s: NimNode): bool {.compileTime.} =
  let n = getImpl(s)
  if n.kind != nnkTypeDef: return false
  if n[2].kind != nnkRefTy: return false
  result = true

proc isObjectType(s: NimNode): bool {.compileTime.} =
  let n = getImpl(s)
  if n.kind != nnkTypeDef: return false
  if n[2].kind != nnkObjectTy: return false
  result = true

proc hasName(name: string): bool {.compileTime.} =
  for n in nameList:
    if n == name: return true
  result = false

proc setName(name: string) {.compileTime.} =
  nameList.add(name)

proc registerObject(subject: NimNode): string {.compileTime.} =
  let name = $subject
  let prefixedName = "nlobj" & name
  for i in 0..nameList.high:
    if nameList[i] == prefixedName:
      return name & $i

  let subjectID = $nameList.len
  let subjectName = name & subjectID
  nameList.add prefixedName
  objectMTList.add "$1.nimNewMetatable(NL_$2)\n" % ["$1", subjectName]
  var glue = "const\n"
  glue.add "  NL_$1 = $2+$3\n" % [subjectName, $IDRegion, subjectID]
  glue.add "  NL_$1name = \"$2\"\n" % [subjectName, name]
  glue.add "type\n"
  glue.add "  NL_$1Proxy = object\n" % [subjectName]
  glue.add "    ud: $1\n" % [name]
  gContext.add glue
  result = subjectName

proc genMetaTableList(SL: string): string {.compileTime.} =
  result = ""
  for n in objectMTList:
    result.add(n % [SL])
  objectMTList.setLen 0

proc checkUD(s, n: string): string {.compileTime.} =
  result = "cast[ptr NL_$1Proxy](L.nimCheckUData($2.cint, NL_$1, NL_$1name))\n" % [s, n]

proc newUD(s: string): string {.compileTime.} =
  result = "cast[ptr NL_$1Proxy](L.newUserData(sizeof(NL_$1Proxy)))\n" % [s]

proc addMemberCap(SL, libName: string, argLen: int): string {.compileTime.} =
  when nloAddMember in gOptions:
    var glue = ""
    glue.add "$1.getGlobal(\"$2\")\n" % [SL, libName]
    glue.add "if not $1.isTable(-1):\n" % [SL]
    glue.add "  $1.pop(1)\n" % [SL]
    glue.add "  $1.createTable(0.cint, $2.cint)\n" % [SL, $(argLen)]
    return glue
  else:
    result = "$1.createTable(0.cint, $2.cint)\n" % [SL, $(argLen)]

proc addClosureEnv(SL, procName: string, n: NimNode, bd: bindDesc, ovIdx: int = 0): string {.compileTime.} =
  var glue = ""

  var params = copy(n[3])
  params.add newIdentDefs(newIdentNode("clEnv"), bindSym"pointer")
  let clv = params.toStrLit.strVal

  glue.add "type clsTyp$1$2 = proc$3 {.nimCall.}\n" % [$proxycount, $ovIdx, clv]
  glue.add "$1.getGlobal(\"$2\")\n" % [SL, globalClosure]
  glue.add "if not $1.isTable(-1):\n" % [SL]
  glue.add "  $1.pop(1)\n" % [SL]
  glue.add "  $1.createTable(0.cint, 2.cint)\n" % [SL]
  glue.add "$1.pushLiteral(\"$2$3env$4\")\n" % [SL, procName, $proxycount, $ovIdx]
  glue.add "$1.pushLightUserData(rawEnv($2))\n" % [Sl, procName]
  glue.add "$1.setTable(-3)\n" % [SL]
  glue.add "$1.pushLiteral(\"$2$3proc$4\")\n" % [SL, procName, $proxycount, $ovIdx]
  glue.add "$1.pushLightUserData(rawProc($2))\n" % [Sl, procName]
  glue.add "$1.setTable(-3)\n" % [SL]
  glue.add "$1.setGlobal(\"$2\")\n" % [SL, globalClosure]
  result = glue

proc getClosureEnv(SL, procName: string, ovIdx: int): string {.compileTime.} =
  var glue = ""
  glue.add "  $1.getGlobal(\"$2\")\n" % [SL, globalClosure]
  glue.add "  let clsTab = $1.getTop()\n" % [SL]
  glue.add "  $1.pushLiteral(\"$2$3env$4\")\n" % [SL, procName, $proxycount, $ovIdx]
  glue.add "  $1.getTable(clsTab)\n" % [SL]
  glue.add "  let clsEnv$2 = $1.toUserData(-1)\n" % [SL, $ovIdx]
  glue.add "  $1.pushLiteral(\"$2$3proc$4\")\n" % [SL, procName, $proxycount, $ovIdx]
  glue.add "  $1.getTable(clsTab)\n" % [SL]
  glue.add "  let clsProc$2 = cast[clsTyp$1$2]($3.toUserData(-1))\n" % [$proxyCount, $ovIdx, SL]
  glue.add "  $1.pop(3)\n" % [SL]
  result = glue

proc nimLuaPanic(L: PState): cint {.cdecl.} =
  echo "panic"
  echo L.toString(-1)
  L.pop(1)
  return 0

proc stdNimLuaErrFunc(ctx: pointer, err: NLError) =
  echo "$1:$2 warning: $3" % [err.source, $err.currentLine, err.msg]

proc NLSetErrorHandler*(L: PState, errFunc: NLErrorFunc) =
  L.pushLightUserData(cast[pointer](IDErrorFunc))
  L.pushLightUserData(cast[pointer](errFunc))
  L.rawSet(LUA_REGISTRYINDEX)

proc NLSetErrorContext*(L: PState, errCtx: pointer) =
  L.pushLightUserData(cast[pointer](IDErrorContext))
  L.pushLightUserData(errCtx)
  L.rawSet(LUA_REGISTRYINDEX)

#call this before you use this library
proc newNimLua*(readOnlyEnum = false): PState =
  var L = newState()
  L.openLibs
  discard L.atPanic(nimLuaPanic)

  L.NLSetErrorHandler(stdNimLuaErrFunc)
  L.NLSetErrorContext(nil)

  const roEnum = """
function readonlytable(table)
  return setmetatable({}, {
    __index = table,
    __newindex = function(table, key, value) error("Attempt to modify read-only table") end,
    __metatable = false
  });
end
"""
  const rwEnum = """
function readonlytable(table)
  return table
end
"""

  const metaMethods = """
function __nlbIndex(myobject, key)
  local mytable = getmetatable(myobject)
  local x = rawget(mytable, "_get_" .. key)
  if x ~= nil then
    return x(myobject)
  else
    return mytable[key]
  end
end
function __nlbNewIndex(myobject, key, value)
  local mytable = getmetatable(myobject)
  local x = rawget(mytable, "_set_" .. key)
  if x ~= nil then
    x(myobject, value)
  else
    mytable[key] = value
  end
end
"""

  const
    nimVer = "Nim = { major = $1, minor = $2, patch = $3 }" %
    [$NimMajor, $NimMinor, $NimPatch]

  discard L.doString(if readOnlyEnum: roEnum else: rwEnum)
  discard L.doString(metaMethods)
  discard L.doString(nimVer)
  result = L

proc propsEnd*(L: PState) =
  L.getGlobal("__nlbIndex")
  L.setField(-2, "__index")
  L.getGlobal("__nlbNewIndex")
  L.setField(-2, "__newindex")

# -------------------------------------------------------------------------
# --------------------------------- bindEnum ------------------------------
# -------------------------------------------------------------------------

proc bindEnumScoped(SL: string, s: NimNode, scopeName: string, kind: NimNodeKind): string {.compileTime.} =
  let x = getImpl(s)
  var err = false
  if x.kind != nnkTypeDef: err = true
  if x[0].kind notin {nnkSym, nnkPragmaExpr}: err = true
  if x[2].kind != nnkEnumTy: err = true
  if err: error("bindEnum: incorrect enum definition")

  var pureEnum = false
  var enumName = ""
  if x[0].kind == nnkPragmaExpr:
    pureEnum = $x[0][1][0] == "pure"

  if pureEnum:
    if x[0][0].kind != nnkSym: error("wrong enum definition")
    enumName = if kind == nnkAccQuoted: "`" & $x[0][0] & "`" else: $x[0][0]
  else:
    enumName = if kind == nnkAccQuoted: "`" & $x[0] & "`" else: $x[0]

  let numEnum = x[2].len - 1
  var glue = ""
  glue.add "$1.getGlobal(\"readonlytable\")\n" % [SL]
  glue.add addMemberCap(SL, scopeName, numEnum)

  for i in 1..numEnum:
    let
      n = x[2][i]
      sym = if n.kind == nnkAccQuoted: "`" & $n[0] & "`" else: $n
    glue.add "discard $1.pushLString(\"$2\", $3)\n" % [SL, sym, $sym.len]
    if pureEnum: glue.add "$1.pushInteger(lua_Integer($2.$3))\n" % [SL, enumName, sym]
    else: glue.add "$1.pushInteger(lua_Integer($2))\n" % [SL, sym]
    glue.add "$1.setTable(-3)\n" % [SL]

  glue.add "discard $1.pcall(1, 1, 0)\n" % [SL]
  glue.add "$1.setGlobal(\"$2\")\n" % [SL, scopeName]
  result = glue

proc bindEnumGlobal(SL: string, s: NimNode, kind: NimNodeKind): string {.compileTime.} =
  let x = getImpl(s)
  var err = false
  if x.kind != nnkTypeDef: err = true
  if x[0].kind notin {nnkSym, nnkPragmaExpr}: err = true
  if x[2].kind != nnkEnumTy: err = true
  if err: error("bindEnum: incorrect enum definition")

  var pureEnum = false
  var enumName = ""
  if x[0].kind == nnkPragmaExpr:
    pureEnum = $x[0][1][0] == "pure"

  if pureEnum:
    if x[0][0].kind != nnkSym: error("wrong enum definition")
    enumName = if kind == nnkAccQuoted: "`" & $x[0][0] & "`" else: $x[0][0]
  else:
    enumName = if kind == nnkAccQuoted: "`" & $x[0] & "`" else: $x[0]

  let numEnum = x[2].len - 1
  var glue = ""
  for i in 1..numEnum:
    let
      n = x[2][i]
      sym = if n.kind == nnkAccQuoted: "`" & $n[0] & "`" else: $n
    if pureEnum: glue.add "$1.pushInteger(lua_Integer($2.$3))\n" % [SL, enumName, sym]
    else: glue.add "$1.pushInteger(lua_Integer($2))\n" % [SL, sym]
    glue.add "$1.setGlobal(\"$2\")\n" % [SL, sym]

  result = glue

#this proc need to be exported because intermediate macro call this proc from
#callsite module
proc bindEnumImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    arg = ctx.bindList

  var glue = ""
  for i in 0..arg.len-1:
    let n = arg[i]
    if n.name == "GLOBAL" and n.rhsKind == nnkIdent: glue.add bindEnumGlobal(SL, n.node, n.lhsKind)
    else: glue.add bindEnumScoped(SL, n.node, n.name, n.lhsKind)

  result = parseCode(glue)

macro bindEnum*(arg: varargs[untyped]): untyped =
  result = genProxyMacro(arg, {}, "Enum")

# -------------------------------------------------------------------------
# ----------------------------- bindFunction ------------------------------
# -------------------------------------------------------------------------

# these are runtime type check helper for each type
# supported by Nim and Lua
proc nimCheckString*(L: PState, idx: cint): string =
  if L.isStrictString(idx): result = L.toString(idx)
  else:
    L.nimDebug(idx.cint, "string")
    result = ""

proc nimCheckBool*(L: PState, idx: cint): bool =
  if L.isBoolean(idx): result = if L.toBoolean(idx) == 0: false else: true
  else:
    L.nimDebug(idx.cint, "bool")
    result = false

proc nimCheckInteger*(L: PState, idx: cint): int =
  if L.isInteger(idx) != 0: result = L.toInteger(idx).int
  else:
    L.nimDebug(idx.cint, "int")
    result = 0

proc nimCheckNumber*(L: PState, idx: cint): float64 =
  if L.isNumber(idx) != 0: result = L.toNumber(idx).float64
  else:
    L.nimDebug(idx.cint, "float")
    result = 0.0

proc nimCheckCstring*(L: PState, idx: cint): cstring =
  if L.isStrictString(idx): result = L.toLString(idx, nil)
  else:
    L.nimDebug(idx.cint, "cstring")
    result = nil

proc nimCheckChar*(L: PState, idx: cint): char =
  if L.isInteger(idx) != 0: result = L.toInteger(idx).char
  else: result = chr(0)

proc nimNewMetaTable*(L: PState, key: int) =
  L.pushLightUserData(cast[pointer](key))
  L.rawGet(LUA_REGISTRYINDEX)
  if not L.isNil(-1): # name already in use?
    L.pop(1)
    return

  L.pop(1) # pop nil
  L.pushLightUserData(cast[pointer](key))
  L.newTable() # create metatable
  L.rawSet(LUA_REGISTRYINDEX)

proc nimGetMetaTable*(L: PState, key: int) =
  L.pushLightUserData(cast[pointer](key))
  L.rawGet(LUA_REGISTRYINDEX)

proc nimCheckUData*(L: PState, idx, key: int, name: string): pointer =
  let p = L.toUserData(idx.cint)
  if p != nil: #value is a userdata?
    if L.getMetaTable(idx.cint) != 0.cint: #does it have a metatable?
      L.pushLightUserData(cast[pointer](key))
      L.rawGet(LUA_REGISTRYINDEX) # get correct metatable
      if L.rawEqual(-1, -2) != 0.cint: # does it have the correct mt?
        L.pop(2) # remove both metatables
        return p

  # else error
  L.nimDebug(idx.cint, name)
  result = nil

let
  intTypes {.compileTime.} = ["int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64"]
  floatTypes {.compileTime.} = ["float", "float32", "float64"]

proc constructBasicArg(mType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = $mType
  for c in intTypes:
    if c == argType:
      return "L.nimCheckInteger(" & $i & ")." & c & "\n"

  for c in floatTypes:
    if c == argType:
      return "L.nimCheckNumber(" & $i & ")." & c & "\n"

  if argType == "string":
    return "L.nimCheckString(" & $i & ")\n"

  if argType == "cstring":
    return "L.nimCheckCstring(" & $i & ")\n"

  if argType == "bool":
    return "L.nimCheckBool(" & $i & ")\n"

  if argType == "char":
    return "L.nimCheckChar(" & $i & ")\n"

  if argType == "pointer":
    return "L.toUserData(" & $i & ")\n"

  result = ""

proc constructBasicRet(mType: NimNode, arg, indent, procName: string): string {.compileTime.} =
  let retType = $mType
  for c in intTypes:
    if c == retType:
      return indent & "L.pushInteger(lua_Integer(" & arg & "))\n"

  for c in floatTypes:
    if c == retType:
      return indent & "L.pushNumber(lua_Number(" & arg & "))\n"

  if retType == "string":
    return indent & "discard L.pushLiteral(" & arg & ")\n"

  if retType == "cstring":
    return indent & "discard L.pushString(" & arg & ")\n"

  if retType == "bool":
    return indent & "L.pushBoolean(" & arg & ".cint)\n"

  if retType == "char":
    return indent & "L.pushInteger(lua_Integer(" & arg & "))\n"

  if retType == "pointer":
    return indent & "L.pushLightUserData(" & arg & ")\n"

  result = ""

proc constructArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string, needCheck: var string): string {.compileTime.}

proc argAttr(mType: NimNode): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType)
    if nType.kind == nnkTypeDef and nType[2].kind in {nnkObjectTy, nnkRefTy}:
      return ".ud"

    if nType.kind == nnkTypeDef and nType[2].kind in {nnkDistinctTy, nnkEnumTy}:
      if nType[0].kind == nnkPragmaExpr:
        return "." & $nType[0][0]
      else: #nnkSym
        return "." & $nType[0]

  if mType.kind == nnkVarTy:
    if getType(mType[0]).kind in {nnkObjectTy, nnkRefTy}:
      return ".ud"

  result = ""

proc stackDump*(L: PState) =
  let top = L.getTop()
  echo "total in stack ", top
  for i in 1..top:
    #repeat for each level
    let t = L.luatype(i)
    case t
    of LUA_TSTRING:
      echo "string: '$1'" % L.toString(i)
    of LUA_TBOOLEAN:
      echo "boolean $1" % [if L.toBoolean(i) == 1: "true" else: "false"]
    of LUA_TNUMBER:
      echo "number: $1" % [$(L.toNumber(i).int)]
    else:
      echo "$1" % [$L.typeName(t)]

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, lo, hi: int, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2$3" % [$s, $lo, $hi]
  var needCheck = ""
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2..$3, $4] =\n" % [name, $lo, $hi, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(("    " & needCheck) % ["tmp"])
      glue.add "      result[i+$1] = tmp$2\n" % [$lo, argAttr(s)]
    else:
      glue.add "    result[i+$1] = tmp$2\n" % [$lo, argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue
  result = name

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, hi: int, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2" % [$s, $hi]
  var needCheck = ""
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2, $3] =\n" % [name, $hi, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(("    " & needCheck) % ["tmp"])
      glue.add "      result[i] = tmp$1\n" % [argAttr(s)]
    else:
      glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, id: string, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2" % [$s, id]
  var needCheck = ""
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2, $3] =\n" % [name, id, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(("    " & needCheck) % ["tmp"])
      glue.add "      result[i] = tmp$1\n" % [argAttr(s)]
    else:
      glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genArrayArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  var lo, hi, mode: int

  if nType[1].kind == nnkInfix:
    lo = int(nType[1][1].intVal)
    hi = int(nType[1][2].intVal)
    mode = 1
  elif nType[1].kind == nnkIntLit:
    lo = 0
    hi = int(nType[1].intVal)
    mode = 2
  elif nType[1].kind == nnkIdent:
    mode = 3
  else:
    error(procName & ": unknown array param type: " & nType.treeRepr)

  let argType = nType[2]

  var needCheck = ""
  let res = constructArg(ctx, argType, -1, procName, needCheck)
  let checkArray = if mode == 1:
      registerArrayCheck(ctx, argType, lo, hi, procName)
    elif mode == 2:
      registerArrayCheck(ctx, argType, hi, procName)
    else:
      registerArrayCheck(ctx, argType, $nType[1], procName)

  var glue = "L.$1($2)\n" % [checkArray, $i]
  if res != "": return glue

  error(procName & ": unknown array param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc registerSetCheck(ctx: proxyDesc, s: NimNode, procName: string): string {.compileTime.} =
  let name = "checkSet$1" % [$s]
  var needCheck = ""
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): set[$2] =\n" % [name, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = L.llen(idx.cint)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(("    " & needCheck) % ["tmp"])
      glue.add "      result.incl(tmp$1)\n" % [argAttr(s)]
    else:
      glue.add "    result.incl(tmp$1)\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genSetArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = nType[1]
  var needCheck = ""
  let res = constructArg(ctx, argType, -1, procName, needCheck)
  let checkSet = registerSetCheck(ctx, argType, procName)
  var glue = "L.$1($2)\n" % [checkSet, $i]
  if res != "": return glue
  error(procName & ": unknown set param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc registerSequenceCheck(ctx: proxyDesc, s: NimNode, procName: string): string {.compileTime.} =
  let name = "checkSequence$1" % [$s]
  var needCheck = ""
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): seq[$2] =\n" % [name, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = L.llen(idx.cint)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  result = newSeq[$1](len)\n" % [$s]
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(("    " & needCheck) % ["tmp"])
      glue.add "      result[i] = tmp$1\n" % [argAttr(s)]
    else:
      glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genSequenceArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = nType[1]
  var needCheck = ""
  let res = constructArg(ctx, argType, -1, procName, needCheck)
  let checkSeq = registerSequenceCheck(ctx, argType, procName)
  var glue = "L.$1($2)\n" % [checkSeq, $i]
  if res != "": return glue
  error(procName & ": unknown seq param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genPtrArg(nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = $nType[0].toStrLit
  result = "cast[ptr $1](L.toUserData($2.cint))\n" % [argType, $i]

proc genRangeArg(nType: NimNode, i: int, procName: string): string {.compileTime.} =
  result = "L.nimCheckInteger($1.cint).int\n" % [$i]

proc registerTupleCheck(ctx: proxyDesc, nType: NimNode, procName: string): string {.compileTime.} =
  let name = "checkTuple$1" % [$proxyCount]

  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): $2 =\n" % [name, nType.toStrLit.strVal]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"

    let argList = paramsToArgListBasic(nType, 0)
    for x in argList:
      glue.add "  L.pushLiteral(\"$1\")\n" % [$x.mName]
      glue.add "  L.getTable(idx.cint)\n"
      var needCheck = ""
      let res = constructArg(ctx, x.mType, -1, procName, needCheck)
      if res == "":
        error(procName & ": unknown tuple param type: " & $x.mType.kind & "\n" & x.mType.treeRepr)
      if needCheck.len != 0:
        glue.add(("    " & needCheck) % [res])
        glue.add "    result.$1 = $2" % [$x.mName, res]
      else:
        glue.add "  result.$1 = $2" % [$x.mName, res]
    glue.add "  L.pop($1)\n" % [$argList.len]
    gContext.add glue

  result = name

proc genTupleArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let checkTup = registerTupleCheck(ctx, nType, procName)
  var glue = "L.$1($2)\n" % [checkTup, $i]
  result = glue

proc constructComplexArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string, needCheck: var string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType)[2]
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      needCheck = "if not $1.isNil:\n"
      return checkUD(registerObject(mType), $i)

    if nType.kind == nnkDistinctTy:
      return constructArg(ctx, nType[0], i, procName, needcheck)

    if nType.kind == nnkEnumTy:
      return constructArg(ctx, bindSym"int", i, procName, needCheck)

    if nType.kind == nnkTupleTy:
      return genTupleArg(ctx, nType, i, procName)

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return genArrayArg(ctx, nType, i, procName)
      if $nType[0] == "set":
        return genSetArg(ctx, nType, i, procName)
      if $nType[0] == "seq":
        return genSequenceArg(ctx, nType, i, procName)
      if $nType[0] == "range":
        return genRangeArg(nType, i, procName)

    if nType.kind == nnkPtrTy:
      return genPtrArg(nType, i, procName)

    if nType.kind == nnkSym:
      return constructBasicArg(nType, i, procName)

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return genArrayArg(ctx, mType, i, procName)
    if $mType[0] == "set":
      return genSetArg(ctx, mType, i, procName)
    if $mType[0] == "seq":
      return genSequenceArg(ctx, mType, i, procName)
    if $mType[0] == "range":
      return genRangeArg(mType, i, procName)
    if ($mType[0]).toLowerAscii == "openarray":
      return genSequenceArg(ctx, mType, i, procName)

  if mType.kind == nnkPtrTy:
    return genPtrArg(mType, i, procName)

  if mType.kind == nnkTupleTy:
    return genTupleArg(ctx, mType, i, procName)

  if mType.kind == nnkVarTy:
    let nType = getType(mType[0])
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      needCheck = "if not $1.isNil:\n"
      return checkUD(registerObject(mType[0]), $i)
    if nType.kind == nnkSym:
      outValList.add constructBasicRet(nType, "arg" & $(i-1), "", procName)
      return constructBasicArg(nType, i, procName)

  if mType.kind == nnkEnumTy:
    return "L.nimCheckInteger($1.cint).$2\n" % [$i, $mType[0]]

  error(procName & ": unknown param type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc constructRet(retType: NimNode, procCall, indent, procName: string): string {.compileTime.}

proc genArrayRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  var lo, hi, mode: int

  if nType[1].kind == nnkInfix:
    lo = int(nType[1][1].intVal)
    hi = int(nType[1][2].intVal)
    mode = 1
  elif nType[1].kind == nnkIntLit:
    lo = 0
    hi = int(nType[1].intVal)
    mode = 2
  elif nType[1].kind == nnkIdent:
    mode = 3
  else:
    error(procName & ": unknown array ret type: " & nType.treeRepr)

  let retType = nType[2]

  var glue = indent & "L.createTable($1+1, 0)\n" % [$hi]
  glue.add indent & "let arrTmp = $1\n" % [procCall]
  var res = ""

  if mode == 1:
    glue.add indent & "for i in $1..$2:\n" % [$lo, $hi]
    glue.add indent & "  L.pushInteger(i-$1+1)\n" % [$lo]
    res = constructRet(retType, "arrTmp[i-$1]" % [$lo], indent & "  ", procName)
    glue.add res
  elif mode == 2:
    glue.add indent & "for i in $1..$2-1:\n" % [$lo, $hi]
    glue.add indent & "  L.pushInteger(i-$1+1)\n" % [$lo]
    res = constructRet(retType, "arrTmp[i-$1]" % [$lo], indent & "  ", procName)
    glue.add res
  else:
    glue.add indent & "for i in 0..$1-1:\n" % [$nType[1]]
    glue.add indent & "  L.pushInteger(i+1)\n"
    res = constructRet(retType, "arrTmp[i]", indent & "  ", procName)
    glue.add res

  glue.add indent & "  L.setTable(-3)\n"

  if res != "": return glue

  error(procName & ": unknown array ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genSetRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  let retType = nType[1]
  var glue = ""

  glue.add indent & "let setTmp = $1\n" % [procCall]
  glue.add indent & "L.createTable((card(setTmp)+1).cint, 0.cint)\n"
  glue.add indent & "var setIdx = 1\n"

  var res = ""
  glue.add indent & "for k in setTmp:\n"
  glue.add indent & "  L.pushInteger(setIdx)\n"
  res = constructRet(retType, "k", indent & "  ", procName)
  glue.add res
  glue.add indent & "  L.setTable(-3)\n"
  glue.add indent & "  inc setIdx\n"
  if res != "": return glue

  error(procName & ": unknown set ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genSequenceRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  let retType = nType[1]
  var glue = ""

  glue.add indent & "let seqTmp = $1\n" % [procCall]
  glue.add indent & "L.createTable((seqTmp.len+1).cint, 0.cint)\n"
  glue.add indent & "var seqIdx = 1\n"

  var res = ""
  glue.add indent & "for k in seqTmp:\n"
  glue.add indent & "  L.pushInteger(seqIdx)\n"
  res = constructRet(retType, "k", indent & "  ", procName)
  glue.add res
  glue.add indent & "  L.setTable(-3)\n"
  glue.add indent & "  inc seqIdx\n"
  if res != "": return glue

  error(procName & ": unknown seq ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genTupleRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  var glue = ""
  glue.add indent & "let tupTmp = $1\n" % [procCall]
  glue.add indent & "L.createTable(0.cint, $1.cint)\n" % [$nType.len]

  let argList = paramsToArgListBasic(nType, 0)

  for x in argList:
    glue.add indent & "L.pushLiteral(\"$1\")\n" % [$x.mName]
    let res = constructRet(x.mType, "tupTmp." & $x.mName, indent, procName)
    if res == "":
      error(procName & ": unknown ret tuple field type: " & $nType.kind & "\n" & nType.treeRepr)
    glue.add res
    glue.add indent & "L.setTable(-3)\n"

  result = glue

proc constructComplexRet(mType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType)[2]

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return genArrayRet(nType, procCall, indent, procName)
      if $nType[0] == "set":
        return genSetRet(nType, procCall, indent, procName)
      if $nType[0] == "seq":
        return genSequenceRet(nType, procCall, indent, procName)
      if $nType[0] == "range":
        return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

    if nType.kind in {nnkObjectTy, nnkRefTy}:
      let subjectName = registerObject(mType)
      var glue = ""
      if isRefType(mType):
        glue.add indent & "var pxret: NL_$1Proxy\n" % [subjectName]
        glue.add indent & "pxret.ud = $1\n" % [procCall]
        glue.add indent & "let proxyret = getRegisteredUD[NL_$1Proxy](L, pxret)\n" % [subjectName]
        glue.add indent & "if proxyret.isNil: return 0\n"
      else:
        glue.add indent & "var proxyret = " & newUD(subjectName)
        glue.add indent & "proxyret.ud = $1\n" % [procCall]

      glue.add indent & "L.nimGetMetatable(NL_$1)\n" % [subjectName]
      glue.add indent & "discard L.setMetatable(-2)\n"
      return glue

    if nType.kind == nnkDistinctTy:
      return constructRet(nType[0], procCall, indent, procName)

    if nType.kind == nnkEnumTy:
      return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

    if nType.kind == nnkTupleTy:
      return genTupleRet(nType, procCall, indent, procName)

    if nType.kind == nnkPtrTy:
      return indent & "L.pushLightUserData(cast[pointer](" & procCall & "))\n"

    if nType.kind == nnkSym:
      return constructRet(nType, procCall, indent, procName)

  if mType.kind == nnkTupleTy:
      return genTupleRet(mType, procCall, indent, procName)

  if mType.kind == nnkPtrTy:
    return indent & "L.pushLightUserData(cast[pointer](" & procCall & "))\n"

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return genArrayRet(mType, procCall, indent, procName)
    if $mType[0] == "set":
      return genSetRet(mType, procCall, indent, procName)
    if $mType[0] == "seq":
      return genSequenceRet(mType, procCall, indent, procName)
    if $mType[0] == "range":
      return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

  if mType.kind == nnkVarTy:
    if getType(mType[0]).kind in {nnkObjectTy, nnkRefTy}:
      let subjectName = registerObject(mType)
      var glue = ""

      if getType(mType[0]).kind == nnkRefTy:
        glue.add indent & "var pxvar: NL_$1Proxy\n" % [subjectName]
        glue.add indent & "pxvar.ud = $1\n" % [procCall]
        glue.add indent & "let proxy = getRegisteredUD[NL_$1Proxy](L, pxvar)\n" % [subjectName]
        glue.add indent & "if proxy.isNil: return 0\n"
      else:
        glue.add indent & "var proxy = " & newUD(subjectName)
        glue.add indent & "proxy.ud = $1\n" % [procCall]

      glue.add indent & "L.nimGetMetatable(NL_$1)\n" % [subjectName]
      glue.add indent & "discard L.setMetatable(-2)\n"
      return glue

  error(procName & ": unknown ret type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc constructArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string, needCheck: var string): string =
  case mType.kind:
  of nnkSym:
    result = constructBasicArg(mType, i, procName)
    if result == "": result = constructComplexArg(ctx, mType, i, procName, needCheck)
  else:
    result = constructComplexArg(ctx, mType, i, procName, needCheck)

proc constructRet(retType: NimNode, procCall, indent, procName: string): string =
  case retType.kind:
  of nnkSym:
    result = constructBasicRet(retType, procCall, indent, procName)
    if result == "": result = constructComplexRet(retType, procCall, indent, procName)
  else:
    result = constructComplexRet(retType, procCall, indent, procName)

proc findSymbol(ctx: proxyDesc, s: NimNode): NimNode =
  for k in ctx.symList:
    if $s == $k: return getType(k)
  result = newEmptyNode()

proc genOvCallSingle(ctx: proxyDesc, ovp: ovProcElem, procName, indent: string, flags: ovFlags, bd: bindDesc, ovIdx: int = 0): string {.compileTime.} =
  var glueParam = ""
  var glue = ""
  let start = if ovfUseObject in flags: 1 else: 0
  outValList = @[]

  if bd.bindKind == isClosure:
    glue.add getClosureEnv("L", procName, ovIdx)

  for i in start..ovp.params.len-1:
    var needCheck = ""
    let param = ovp.params[i]
    let pType = if param.mType.kind != nnkEmpty: param.mType else: findSymbol(ctx, param.mVal)
    glue.add indent & "  var arg" & $i & " = " & constructArg(ctx, pType, i + 1, procName, needCheck)
    if needCheck.len != 0:
      glue.add(indent & "  if arg" & $i & ".isNil: return 0\n")
    glueParam.add "arg" & $i & argAttr(param.mType)
    if i < ovp.params.len-1: glueParam.add ", "

  let comma = if glueParam.len == 0: "" else: ", "
  if ovfConstructor in flags:
    let procCall = if bd.bindKind == isClosure:
        "clsProc$3($1$2clsEnv$3)" % [glueParam, comma, $ovIdx]
      else:
        procName & "(" & glueParam & ")"
    glue.add indent & "  proxy.ud = " & procCall & "\n"
  else:
    let procCall = if ovfUseObject in flags:
        if bd.bindKind == isClosure:
          "proxy.ud.clsProc$3($1$2clsEnv$3)" % [glueParam, comma, $ovIdx]
        else:
          "proxy.ud.$1($2)" % [procName, glueParam]
      else:
        if bd.bindKind == isClosure:
          "clsProc$3($1$2clsEnv$3)" % [glueParam, comma, $ovIdx]
        else:
          procName & "(" & glueParam & ")"

    if ovfUseRet in flags:
      var numRet = 0
      if ovp.retType.kind == nnkEmpty:
        glue.add indent & "  " & procCall & "\n"
      else:
        glue.add constructRet(ovp.retType, procCall, indent & "  ", procName)
        numRet = 1

      inc(numRet, outValList.len)
      for s in outValList:
        glue.add "$1  $2" % [indent, s]

      glue.add "$1  return $2\n" % [indent, $numRet]
  result = glue

proc bindSingleFunction(ctx: proxyDesc, bd: bindDesc, n: NimNode, glueProc, procName, SL: string): string {.compileTime.} =
  if n.kind != nnkProcDef:
    error("bindFunction: " & procName & " is not a proc")

  let params = n[3]
  let retType = replaceRet(params[0], bd.genericParams, n[2])
  let argList = paramsToArgList(params, bd.genericParams, n[2])

  var glue = ""
  if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd)
  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfUseRet}, bd)
  result = glue

proc genBasicCheck(mType: NimNode, i: int, procNane: string): string {.compileTime.} =
  let argType = $mType
  for c in intTypes:
    if c == argType:
      return "(L.isInteger(" & $i & ") == 1)"

  for c in floatTypes:
    if c == argType:
      return "(L.isNumber(" & $i & ") == 1)"

  if argType == "string":
    return "(L.isStrictString(" & $i & ") == true)"

  if argType == "cstring":
    return "(L.isStrictString(" & $i & ") == true)"

  if argType == "bool":
    return "L.isBoolean(" & $i & ")"

  if argType == "char":
    return "(L.isInteger(" & $i & ") == 1)"

  if argType == "pointer":
    return "(L.isUserData(" & $i & ") == 1)"

  result = ""

proc genCheckType(mType: NimNode, i: int, procName: string): string {.compileTime.}

proc genComplexCheck(mType: NimNode, i: int, procName: string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType)[2]
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return "(L.isUserData(" & $i & ") == 1)"

    if nType.kind == nnkDistinctTy:
      return genCheckType(nType, i, procName)

    if nType.kind == nnkEnumTy:
      return "(L.isInteger(" & $i & ") == 1)"

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "set":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "seq":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "range":
        return "L.isTable(" & $i & ")"

    if nType.kind == nnkPtrTy:
      return "(L.isLightUserData(" & $i & ") == 1)"

    if nType.kind == nnkSym:
      if $nType == "pointer":
        return "(L.isLightUserData(" & $i & ") == 1)"

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "set":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "seq":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "range":
      return "(L.isInteger(" & $i & ") == 1)"

  if mType.kind == nnkPtrTy:
    return "(L.isLightUserData(" & $i & ") == 1)"

  if mType.kind == nnkVarTy:
    let nType = getType(mType[0])
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return "(L.isUserData(" & $i & ") == 1)"
    if nType.kind == nnkSym:
      return genCheckType(nType, i, procName)

  if mType.kind == nnkEnumTy:
    return "(L.isInteger(" & $i & ") == 1)"

  error(procName & " : unknown param type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc genCheckType(mType: NimNode, i: int, procName: string): string =
  case mType.kind:
  of nnkSym:
    result = genBasicCheck(mType, i, procName)
    if result == "": result = genComplexCheck(mType, i, procName)
  else:
    result = genComplexCheck(mType, i, procName)

#second level of ov proc resolution
proc genCheck(params: seq[argDesc], flags: ovFlags, procName: string): string {.compileTime.} =
  var glue = "    if "
  let start = if ovfUseObject in flags: 1 else: 0
  for i in start..params.len-1:
    glue.add genCheckType(params[i].mType, i + 1, procName)
    if i < params.len-1:
      glue.add " and "
    else:
      glue.add ":\n"
  result = glue

#overloaded proc need to be resolved by their params count and params type
#genCheck generate code to check params type
proc genOvCallMany(ctx: proxyDesc, ovp: seq[ovProcElem], procName: string, flags: ovFlags, bd: bindDesc): string {.compileTime.} =
  var glue = ""
  var i = 0
  for ov in ovp:
    glue.add genCheck(ov.params, flags, procName)
    glue.add genOvCallSingle(ctx, ov, procName, "    ", flags, bd, i)
    inc i
  result = glue

proc genOvCall(ctx: proxyDesc, ovp: seq[ovProc], procName: string, flags: ovFlags, bd: bindDesc): string {.compileTime.} =
  var glue = "  let numArgs = L.getTop().int\n"
  for i in 0..<ovp.len:
    let k = ovp[i]
    let prefix = if i == 0: "" else: "el"
    glue.add "  $1if numArgs == $2:\n" % [prefix, $k.numArgs] #first level of ov proc resolution
    if k.procs.len == 1:
      glue.add genOvCallSingle(ctx, k.procs[0], procName, "  ", flags, bd)
    else:
      glue.add genOvCallMany(ctx, k.procs, procName, flags, bd)
  glue.add "  else:\n"
  glue.add "    # error\n"
  glue.add "    return 0\n"
  result = glue

proc bindOverloadedFunction(ctx: proxyDesc, bd: bindDesc, ov: NimNode, glueProc, procName, SL: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()
  var glue = ""

  var i = 0
  for s in children(ov):
    let n = getImpl(s)
    if n.kind != nnkProcDef:
      error("bindObject: " & procName & " is not a proc")

    if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd, i)
    let params = n[3]
    let retType = replaceRet(params[0], bd.genericParams, n[2])
    let argList = paramsToArgList(params, bd.genericParams, n[2])
    ovl.addOvProc(retType, argList)
    inc i

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add genOvCall(ctx, ovl, procName, {ovfUseRet}, bd)
  glue.add "  discard luaError(L, \"$1: invalid param count\")\n" % [procName]
  glue.add "  return 0\n"

  result = glue

#this proc is exported because of the NLBFunc macro expansion occured on bindFunction caller module
proc bindFunctionImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    libName = if ctx.libName.kind != nnkEmpty: $ctx.libName else: ""
    libKind = ctx.libName.kind
    arg = ctx.bindList
    exportLib = libName != "" and libName != "GLOBAL" or (libName == "GLOBAL" and libKind == nnkStrLit)

  gContext.setLen 0
  var glue = ""
  if exportLib:
    glue.add addMemberCap(SL, libName, arg.len)

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind notin {nnkSym, nnkClosedSymChoice}:
      error("bindFunction: arg[" & $i & "] need symbol not " & $n.node.kind)

    let
      procName = getAccQuotedName(n.node, n.lhsKind)
      glueProc = "nimLUAproxy" & $proxyCount
      exportedName = n.name

    if n.node.kind == nnkSym:
      glue.add bindSingleFunction(ctx, n, getImpl(n.node), glueProc, procName, SL)
    else: #nnkClosedSymChoice
      glue.add bindOverloadedFunction(ctx, n, n.node, glueProc, procName, SL)

    if exportLib:
      glue.add "discard " & SL & ".pushString(\"" & exportedName & "\")\n"
      glue.add SL & ".pushCfunction(" & glueProc & ")\n"
      glue.add SL & ".setTable(-3)\n"
    else:
      glue.add SL & ".pushCfunction(" & glueProc & ")\n"
      glue.add SL & ".setGlobal(\"" & exportedName & "\")\n"

    inc proxyCount

  if exportLib:
    glue.add SL & ".setGlobal(\"" & libName & "\")\n"

  let mtList = genMetaTableList(SL)
  result = parseCode(gContext & mtList & glue)

#call this macro with following params pattern:
# * bindFunction(luaState, "libName", ident1, ident2, .., identN)
#     -> export nim function(s) with lua scope named "libName"
# * bindFunction(luaState, ident1, ident2, .., identN)
#     -> export nim function(s) to lua global scope

macro bindFunction*(arg: varargs[untyped]): untyped =
  result = genProxyMacro(arg, {nlbUSeLib, nlbRegisterClosure, nlbRegisterGeneric}, "Function")

macro bindProc*(arg: varargs[untyped]): untyped =
  result = genProxyMacro(arg, {nlbUSeLib, nlbRegisterClosure, nlbRegisterGeneric}, "Function")

# ----------------------------------------------------------------------
# ----------------------------- bindConst ------------------------------
# ----------------------------------------------------------------------

proc constructConstBasic(SL, name, indent: string, n: NimNode): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = indent & "when not internalTestForBOOL($1[0]):\n" % [name]
    nlb.add indent & "  $1.pushInteger(lua_Integer($2[i]))\n" % [SL, name]
    nlb.add indent & "else:\n"
    nlb.add indent & "  $1.pushBoolean($2[i].cint)\n" % [SL, name]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return indent & "$1.pushNumber(lua_Number($2[i]))\n" % [SL, name]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return indent & "discard $1.pushLString($2[i], $2[i].len)\n" % [SL, name]

  result = ""

proc constructConstParBasic(SL, indent: string, n: NimNode, name: string, idx: int): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = indent & "when not internalTestForBOOL($2[0][0]):\n" % [SL, name]
    nlb.add indent & "  $1.pushInteger(lua_Integer($2[i][$3]))\n" % [SL, name, $idx]
    nlb.add indent & "else:\n"
    nlb.add indent & "  $1.pushBoolean($2[i][$3].cint)\n" % [SL, name, $idx]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return indent & "$1.pushNumber(lua_Number($2[i][$3]))\n" % [SL, name, $idx]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return indent & "discard $1.pushLString($2[i][$3], $2[i][$3].len)\n" % [SL, name, $idx]

  result = ""

proc constructConstPar(SL, name, indent: string, n: NimNode): string {.compileTime.} =
  result = constructConstParBasic(SL, indent, n[0], name, 0)
  result.add constructConstParBasic(SL, indent, n[1], name, 1)

proc constructConst(SL: string, n: NimNode, name: string): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = "when not internalTestForBOOL($1):\n" % [name]
    nlb.add "  $1.pushInteger(lua_Integer($2))\n" % [SL, $(n.intVal)]
    nlb.add "else:\n"
    nlb.add "  $1.pushBoolean($2.cint)\n" % [SL, $(n.intVal)]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return "$1.pushNumber(lua_Number($2))\n" % [SL, $(n.floatVal)]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return "discard $1.pushLString(\"$2\", $3)\n" % [SL, n.strVal, $(n.strVal.len)]

  if n.kind == nnkBracket:
    if n[0].kind in {nnkCharLit..nnkTripleStrLit}:
      var nlb = "$1.createTable($2, 0)\n" % [SL, $n.len]
      nlb.add "for i in 0..$1:\n" % [$(n.len-1)]
      nlb.add constructConstBasic(SL, name, "  ", n[0])
      nlb.add "  $1.rawSeti(-2, i)\n" % [SL]
      return nlb
    elif n[0].kind in {nnkPar, nnkTupleConstr}:
      if n[0].len == 2:
        var nlb = "$1.createTable(0, $2)\n" % [SL, $n.len]
        nlb.add "for i in 0..$1:\n" % [$(n.len-1)]
        nlb.add constructConstPar(SL, name, "  ", n[0])
        nlb.add "  $1.setTable(-3)\n" % [SL]
        return nlb

  result = ""

proc bindConstImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    libName = if ctx.libName.kind != nnkEmpty: $ctx.libName else: ""
    libKind = ctx.libName.kind
    arg = ctx.bindList
    exportLib = libName != "" and libName != "GLOBAL" or (libName == "GLOBAL" and libKind == nnkStrLit)

  var glue = ""
  if exportLib:
    glue.add addMemberCap(SL, libName, arg.len)

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind != nnkSym:
      error("bindConst: arg[" & $i & "] need symbol not " & $n.node.kind)

    let exportedName = n.name

    if exportLib:
      glue.add "discard " & SL & ".pushString(\"" & exportedName & "\")\n"
      glue.add constructConst(SL, getImpl(n.node), $n.node)
      glue.add SL & ".setTable(-3)\n"
    else:
      glue.add constructConst(SL, getImpl(n.node), $n.node)
      glue.add SL & ".setGlobal(\"" & exportedName & "\")\n"

  if exportLib:
    glue.add SL & ".setGlobal(\"" & libName & "\")\n"

  result = parseCode(glue)

macro bindConst*(arg: varargs[untyped]): untyped =
  result = genProxyMacro(arg, {nlbUseLib}, "Const")

# -----------------------------------------------------------------------
# ----------------------------- bindObject ------------------------------
# -----------------------------------------------------------------------

proc bindSingleConstructor(ctx: proxyDesc, bd: bindDesc, n: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  if n.kind notin {nnkProcDef, nnkTemplateDef}:
    error("bindFunction: " & procName & " is not a proc")

  let
    params = n[3]
    retType = replaceRet(params[0], bd.genericParams, n[2])
    SL = ctx.luaCtx
    subject = ctx.subject

  if subject.kind != retType.kind and $subject != $retType:
    error("invalid constructor ret type")

  let argList = paramsToArgList(params, bd.genericParams, n[2])

  var glue = ""
  if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd)
  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  if isRefType(subject):
    glue.add "  var proxy: NL_$1Proxy\n" % [subjectName]
    glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfConstructor}, bd)
    glue.add "  let ret = getRegisteredUD[NL_$1Proxy](L, proxy)\n" % [subjectName]
    glue.add "  if ret.isNil: return 0\n"
  else:
    glue.add "  var proxy = " & newUD(subjectName)
    #always zeroed the memory if you mix gc code and unmanaged code
    #otherwise, strange things will happened
    if isObjectType(subject): glue.add "  zeroMem(proxy, sizeof(NL_$1Proxy))\n" % [subjectName]
    glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfConstructor}, bd)

  glue.add "  L.nimGetMetatable(NL_$1)\n" % [subjectName]
  glue.add "  discard L.setMetatable(-2)\n"
  glue.add "  result = 1\n"
  result = glue

proc eqType(a, b: NimNode): bool {.compileTime.} =
  if a.kind == nnkSym and b.kind == nnkVarTy:
    if sameType(a, b[0]): return true
  result = sameType(a, b)

proc getParentName(n: NimNode, res: var seq[string]) =
  var prefix = ""
  var a = getImpl(n)[2]
  if a.kind notin {nnkObjectTy, nnkRefTy}: return
  if a.kind == nnkRefTy:
    a = a[0]
    prefix = "ref "
    if a.kind != nnkObjectTy: return
  a = a[1]
  if a.kind != nnkOfInherit: return
  res.add(prefix & $a[0])
  getParentName(a[0], res)

proc isDescendant(a, b: NimNode): bool {.compileTime.} =
  if b.kind notin {nnkRefTy, nnkSym}: return false
  let bType = if b.kind == nnkRefTy: "ref " & $b[0] else: $b
  var parents = newSeq[string]()
  getParentName(a, parents)
  result = parents.contains(bType)

proc eqTypeOrDescendant(a, b: NimNode): bool {.compileTime.} =
  result = eqType(a, b) or isDescendant(a, b)

proc getRegisteredUD*[T](L: PState, proxy: T): ptr T =
  # get ref type userdata from REGISTRYINDEX
  # if it's already there or create one if it's not there
  # this help us to communicate with lua side from Nim
  if proxy.ud == nil: return nil

  # proxy.ud must be larger than NLMaxID
  doAssert((cast[int](proxy.ud) and (not NLMaxID)) != 0)

  L.pushLightUserData(cast[pointer](proxy.ud))
  L.rawGet(LUA_REGISTRYINDEX)
  if not L.isNil(-1): # name already in use?
    result = cast[ptr T](L.toUserData(-1))
    result.ud = proxy.ud
    return result

  L.pop(1) # pop nil
  result = cast[ptr T](L.newUserData(sizeof(T)))
  L.pushLightUserData(cast[pointer](proxy.ud))
  L.pushValue(-2)
  L.rawSet(LUA_REGISTRYINDEX)

  #always zeroed the memory if you mix gc code and non gc code
  zeroMem(result, sizeof(T))
  result.ud = proxy.ud
  GC_ref(result.ud)

proc bindOverloadedConstructor(ctx: proxyDesc, bd: bindDesc, ov: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()

  let
    SL = ctx.luaCtx
    subject = ctx.subject

  var glue = ""
  var i = 0

  for s in children(ov):
    let n = getImpl(s)
    if n.kind != nnkProcDef:
      error("bindObject: " & procName & " is not a proc")

    if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd, i)
    let params = n[3]
    let retType = replaceRet(params[0], bd.genericParams, n[2])
    let argList = paramsToArgList(params, bd.genericParams, n[2])

    #not a valid constructor
    if subject.kind != retType.kind and not eqTypeOrDescendant(subject, retType): continue
    ovl.addOvProc(retType, argList)
    inc i

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  if isRefType(subject):
    glue.add "  var proxy: NL_$1Proxy\n" % [subjectName]
    glue.add genOvCall(ctx, ovl, procName, {ovfConstructor}, bd)
    glue.add "  let ret = getRegisteredUD[NL_$1Proxy](L, proxy)\n" % [subjectName]
    glue.add "  if ret.isNil: return 0\n"
  else:
    glue.add "  var proxy = " & newUD(subjectName)
    #always zeroed the memory if you mix gc code and unmanaged code
    #otherwise, strange things will happened
    if isObjectType(subject): glue.add "  zeroMem(proxy, sizeof(NL_$1Proxy))\n" % [subjectName]
    glue.add genOvCall(ctx, ovl, procName, {ovfConstructor}, bd)

  glue.add "  L.nimGetMetatable(NL_$1)\n" % [subjectName]
  glue.add "  discard L.setMetatable(-2)\n"
  glue.add "  result = 1\n"
  result = glue

proc bindObjectSingleMethod(ctx: proxyDesc, bd: bindDesc, n: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  if n.kind notin {nnkProcDef, nnkTemplateDef}:
    error("bindFunction: " & procName & " is not a proc/template")

  let
    params = n[3]
    retType = replaceRet(params[0], bd.genericParams, n[2])
    argList = paramsToArgList(params, bd.genericParams, n[2])
    SL = ctx.luaCtx
    subject = ctx.subject

  if eqTypeOrDescendant(subject, retType):
    return bindSingleConstructor(ctx, bd, n, glueProc, procName, subjectName)

  if argList.len == 0:
    error(procName & ": invalid object method")

  if not eqTypeOrDescendant(subject, argList[0].mType):
    error("object method need object type as first param: " & procName)

  var glue = ""
  if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd)
  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add "  if proxy.isNil: return 0\n"
  glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfUseObject, ovfUseRet}, bd)
  result = glue

proc bindObjectOverloadedMethod(ctx: proxyDesc, bd: bindDesc, ov: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()
  var ovc = newNimNode(nnkClosedSymChoice)
  let
    SL = ctx.luaCtx
    subject = ctx.subject

  var glue = ""
  var i = 0

  for s in children(ov):
    let n = getImpl(s)
    if n.kind notin {nnkProcDef, nnkTemplateDef}:
      error("bindConstructor: " & procName & " is not a proc/template")

    if bd.bindKind == isClosure: glue.add addClosureEnv(SL, procName, n, bd, i)
    let params = n[3]
    let retType = replaceRet(params[0], bd.genericParams, n[2])
    let argList = paramsToArgList(params, bd.genericParams, n[2])

    if eqTypeOrDescendant(subject, retType): #constructor like
      ovc.add s
      continue

    if argList.len == 0: continue #not a valid object method
    if not eqTypeOrDescendant(subject, argList[0].mType): continue
    ovl.addOvProc(retType, argList)
    inc i

  if ovc.len > 0:
    glue.add bindOverloadedConstructor(ctx, bd, ovc, glueProc, procName, subjectName)
    return glue

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add "  if proxy.isNil: return 0\n"
  glue.add genOvCall(ctx, ovl, procName, {ovfUseObject, ovfUseRet}, bd)
  glue.add "  discard luaError(L, \"$1: invalid param count\")\n" % [procName]
  glue.add "  return 0\n"
  result = glue

proc bindGetter(ctx: proxyDesc, glueProc, propName, subjectName: string, propType, subject: NimNode): string {.compileTime.} =
  var glue = ""

  let
    procCall = "proxy.ud." & propName
    procName = $subject & "." & propName

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add "  if proxy.isNil: return 0\n"
  glue.add constructRet(propType, procCall, "  ", procName)
  glue.add "  return 1\n"
  result = glue

proc bindSetter(ctx: proxyDesc, glueProc, propName, subjectName: string, propType, subject: NimNode): string {.compileTime.} =
  var glue = ""
  var needCheck = ""

  let
    procCall = "proxy.ud." & propName
    procName = $subject & "." & propName

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add "  if proxy.isNil: return 0\n"
  glue.add "  $1 = $2" % [procCall, constructArg(ctx, propType, 2, procName, needCheck)]
  glue.add "  return 0\n"
  result = glue

proc getPropType(subject: NimNode, prop: string): NimNode {.compileTime.} =
  let parent = if subject.kind == nnkRefTy: subject[0][1] else: subject[1]
  if parent.kind == nnkOfInherit:
    let parentName = parent[0]
    var t = getTypeImpl(parentName)
    if t.kind == nnkRefTy: t = getTypeImpl(t[0])
    let ret = getPropType(t, prop)
    if ret != nil: return ret

  let recList = if subject.kind == nnkRefTy: subject[0][2] else: subject[2]
  for n in recList:
    for i in 0..n.len-3:
      let k = n[i]
      if k.kind in {nnkIdent, nnkSym}:
        if $k == prop: return n[n.len-2]
      elif k.kind == nnkPostfix:
        if $k[1] == prop: return n[n.len-2]
      else:
        error("unknown prop construct")

proc bindObjectImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    newName = $ctx.libName
    subject = ctx.subject
    arg = ctx.bindList

  gContext.setLen 0
  let subjectName = registerObject(subject)
  var glue = ""
  var regs = "var regs$1$2 = [\n" % [subjectName, $regsCount]

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind notin {nnkSym, nnkClosedSymChoice}:
      error("bindObject: arg[" & $i & "] need symbol not " & $n.node.kind)

    let
      procName = getAccQuotedName(n.node, n.lhsKind)
      glueProc = "nimLUAproxy" & $proxyCount
      exportedName = if n.name == "constructor": "new" else: n.name

    regs.add "  luaL_Reg(name: \"$1\", fn: $2),\n" % [exportedName, glueProc]

    if n.node.kind == nnkSym:
      if n.name == "constructor" and n.lhsKind != nnkStrLit:
        glue.add bindSingleConstructor(ctx, n, getImpl(n.node), glueProc, procName, subjectName)
      else:
        glue.add bindObjectSingleMethod(ctx, n, getImpl(n.node), glueProc, procName, subjectName)
    else: #nnkClosedSymChoice
      if n.name == "constructor" and n.lhsKind != nnkStrLit:
        glue.add bindOverloadedConstructor(ctx, n, n.node, glueProc, procName, subjectName)
      else:
        glue.add bindObjectOverloadedMethod(ctx, n, n.node, glueProc, procName, subjectName)

    inc proxyCount

  if ctx.propList.len > 0:
    for n in ctx.propList:
      let
        propName   = getAccQuotedName(n.node, n.lhsKind)
        getterProc = "nimLUAgetter" & $proxyCount
        setterProc = "nimLUAsetter" & $proxyCount
        subjectT   = getImpl(subject)
        propType   = getPropType(subjectT[2], propName)

      if propType == nil:
        error("'$1': not a prop of $2" % [propName, $subjectT[0]])

      if n.getter:
        regs.add "  luaL_reg(name: \"_get_$1\", fn: $2),\n" % [n.name, getterProc]
        glue.add bindGetter(ctx, getterProc, propName, subjectName, propType, subject)

      if n.setter:
        regs.add "  luaL_reg(name: \"_set_$1\", fn: $2),\n" % [n.name, setterProc]
        glue.add bindSetter(ctx, setterProc, propName, subjectName, propType, subject)

      inc proxyCount

  if isRefType(subject) and not hasName("dtor" & $subject):
    glue.add "proc $1_destructor(L: PState): cint {.cdecl.} =\n" % [subjectName]
    glue.add "  var proxy = " & checkUD(subjectName, "1")
    glue.add "  if proxy.isNil: return 0\n"
    glue.add "  GC_unref(proxy.ud)\n"
    glue.add "  proxy.ud = nil\n"
    regs.add "  luaL_reg(name: \"__gc\", fn: $1_destructor),\n" % [subjectName]
    setName("dtor" & $subject)

  regs.add "  luaL_Reg(name: nil, fn: nil)\n"
  regs.add "]\n"

  glue.add regs
  glue.add "$1.nimGetMetatable(NL_$2)\n" % [SL, subjectName]
  glue.add "$1.setFuncs(cast[ptr luaL_reg](addr(regs$2$3)), 0)\n" % [SL, subjectName, $regsCount]

  if ctx.propList.len > 0:
    glue.add "$1.propsEnd()\n" % [SL]
  else:
    glue.add "$1.pushValue(-1)\n" % [SL]
    glue.add "$1.setField(-1, \"__index\")\n" % [SL]
  glue.add "$1.setGlobal(\"$2\")\n" % [SL, newName]

  inc regsCount
  let mtList = genMetaTableList(SL)
  result = parseCode(gContext & mtList & glue)

macro bindObject*(arg: varargs[untyped]): untyped =
  result = genProxyMacro(arg, {nlbRegisterObject, nlbRegisterClosure, nlbRegisterGeneric}, "Object")

# use this macro to generate alias for object meta table name dan proxy name
macro getRegisteredType*(obj: typed, metaTableName, proxyName: untyped): untyped =
  let subjectName = registerObject(obj)
  var glue = "type $1 = NL_$2Proxy\n" % [$proxyName, subjectName]
  glue.add "const $1 = NL_$2\n" % [$metaTableName, subjectName]
  result = parseCode(glue)

macro getRegisteredProxy*(obj: typed, proxyName: untyped): untyped =
  let subjectName = registerObject(obj)
  var glue = "type $1 = NL_$2Proxy\n" % [$proxyName, subjectName]
  result = parseCode(glue)

macro getRegisteredMetaTable*(obj: typed, metaTableName: untyped): untyped =
  let subjectName = registerObject(obj)
  var glue = "const $1 = NL_$2\n" % [$metaTableName, subjectName]
  result = parseCode(glue)

macro instantiateRegisteredProxy(obj: typed): untyped =
  let n = getTypeImpl(obj)
  assert(n.kind == nnkBracketExpr)
  var glue = "type pxName = object\n"
  glue.add "  ud: $1\n" % [$n[1]]
  glue.add "let px = pxName(ud: objRef)\n"
  glue.add "let proxy = getRegisteredUD[pxName](L, px)\n"
  glue.add "result = proxy.ud\n"
  result = parseCode(glue)

proc getUD*[T: ref](L: PState, objRef: T): T =
  instantiateRegisteredProxy(T)

# -----------------------------------------------------------------------
# ------------------------------ importLua ------------------------------
# -----------------------------------------------------------------------

# TODO: call method on lua object
# TODO: call with lua values
# TODO: tests

macro importLua(usage: string, toImport: typed): untyped =
  # usage has the same rules as importCpp
  # except for the operator usage
  #
  # as function
  # name(@)
  # table.table.table.name(@)
  #
  # as method
  # #:name(@)
  #
 
  # Check proc def if it is legal
  #  Reject generics
  if toImport[2].kind != nnkEmpty:
    error("Lua-imported function is generic; Lua has no generics", toImport[2])

  #  Reject all unknown pragmas
  if toImport[4].kind != nnkEmpty:
    error("Lua-imported function has unknown pragma; this cannot be applied to it", toImport[4])

  #  Reject if proc has body
  #  * importc does not do this...
  if false: # toImport[6].kind != nnkEmpty:
    error("Lua-imported function has body; use bindFunction instead", toImport[2])


  # Parse usage
  if false:
    discard
  else:
    error("Unknown usage syntax")

  # Generate code from usage and proc def
  discard

  # how to use this macro?
  # proc name(a: int): tuple[a: string, b: int] {.importLua: "".} 

